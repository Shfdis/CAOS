Ермошкин Артём Дмитриевич
Группа: 245
Вариант: 36

УСЛОВИЕ ЗАДАЧИ
N студентов организовали турнир в игру Камень, ножницы, бумага по олимпийской системе. Каждый студент отдельный поток. Выбор генерируется случайно. Одновременно могут протекать несколько поединков. При ничьей игра продолжается до победы.

СЦЕНАРИЙ РЕШАЕМОЙ ЗАДАЧИ
N студентов в отдельных потоках участвуют в турнире. В каждом раунде студенты разбиваются на пары и одновременно делают выбор. Победитель проходит дальше, проигравший выбывает. При ничьей поединок повторяется. Процесс продолжается до одного победителя.

МОДЕЛЬ ПАРАЛЛЕЛЬНЫХ ВЫЧИСЛЕНИЙ
Модель с разделяемой памятью. Каждый студент отдельный поток POSIX Thread. Синхронизация через семафоры и мьютексы в program1, через условные переменные, барьеры и атомарные переменные в program2.

ВХОДНЫЕ ДАННЫЕ
Количество участников N от 2 до 1024. Ввод через аргумент командной строки или файл -c. Вывод в файл -o.
Генератор Program1: rand_r с seed на основе времени и ID потока.
Генератор Program2: rand() под защитой мьютекса rand_lock (потокобезопасный).
Диапазон 0-2: камень, ножницы, бумага.

РЕАЛИЗАЦИЯ
Program1: семафоры sem_t и мьютексы pthread_mutex_t. Program2: условные переменные pthread_cond_t, барьеры pthread_barrier_t, атомарные переменные atomic_int, мьютексы.

ИЗМЕНЕНИЯ ДЛЯ ПОЛУЧЕНИЯ ОЦЕНОК

4-5 баллов:
Структуры: Student (num, ch, alive, thr), Duel (p1, p2, rnd, done, ready)
Синхропримитивы: sem_t start_round, sem_t ready в Duel, pthread_mutex_t game_lock, pthread_mutex_t print_lock
Ввод: scanf("%d", &n) в main
Функции: student_func, setup_round, who_wins, log_print (только printf)

6-7 баллов:
Замена scanf на парсинг argv: for (int i = 1; i < argc; i++) { n = atoi(argv[i]); }
Генерация: rand_r(&rseed) % 3, seed = time(NULL) ^ (my_id * 1000)

8 баллов:
Добавлена переменная FILE* logfile
Парсинг ключей: if (strcmp(argv[i], "-c") == 0) cfg_path = argv[++i]; if (strcmp(argv[i], "-o") == 0) out_path = argv[++i];
Чтение конфига: FILE* f = fopen(cfg_path, "r"); fscanf(f, "%d", &n); fclose(f);
Запись в файл: logfile = fopen(out_path, "w"); в log_print добавлен vfprintf(logfile, fmt, ap)

9-10 баллов:
Program2: структуры Participant (num, atomic_int choice, atomic_int active), Battle (p1, p2, atomic_int rnd_done, atomic_int ready_count, pthread_cond_t cond, pthread_mutex_t mut)
Замена sem_t на pthread_barrier_t round_barrier
Замена обычных переменных на atomic_int: remaining_count, tournament_running, choice, active, ready_count
Функции: participant_thread вместо student_func, run_tournament вместо setup_round
Синхронизация: pthread_barrier_wait(&round_barrier), pthread_cond_wait/broadcast, atomic_store/load, мьютекс rand_lock для rand()

РЕЗУЛЬТАТЫ РАБОТЫ ПРОГРАММЫ

Результаты работы программы записываются в файлы при использовании ключа -o.
Примеры выходных файлов находятся в соответствующих директориях программ:
Program1 (директория program1/):
- output1.txt (N=4, конфигурация test_config2.txt)
- output2.txt (N=8, конфигурация test_config1.txt)
- output3.txt (N=16, конфигурация test_config3.txt)

Program2 (директория program2/):
- output1.txt (N=4, конфигурация test_config2.txt)
- output2.txt (N=8, конфигурация test_config1.txt)
- output3.txt (N=16, конфигурация test_config3.txt)

Пример работы Program1 (N=8, ввод из конфига test_config1.txt):
 Начало турнира. Участников: 8 

 Раунд 1: 8 участников 
Раунд 1: Студент 0 (Камень) vs Студент 1 (Ножницы)
Победитель поединка: Студент 0
Раунд 1: Студент 4 (Камень) vs Студент 5 (Камень)
Ничья! Переигровка...
Раунд 1 (переигровка): Студент 4 (Бумага) vs Студент 5 (Камень)
Победитель поединка: Студент 4
...
 ПОБЕДИТЕЛЬ ТУРНИРА: Студент 2 

Пример работы Program2 (N=8, ввод из конфига test_config1.txt):
 Начало турнира. Участников: 8 

 Раунд 1: 8 участников 
Раунд 1: Студент 0 (Ножницы) vs Студент 1 (Ножницы)
Ничья! Переигровка...
Раунд 1: Студент 6 (Ножницы) vs Студент 7 (Бумага)
Победитель поединка: Студент 6
...
 ПОБЕДИТЕЛЬ ТУРНИРА: Студент 0 

ТЕСТИРОВАНИЕ

Тест 1: Program1, ввод из командной строки, N=4
Команда: ./tournament 4
Результат: успешно, определен победитель (Студент 3)
Вывод (p1_test1.log): 2 раунда, корректное определение победителей поединков.

Тест 2: Program1, ввод из конфигурационного файла, N=8
Команда: ./tournament -c test_config1.txt
Результат: успешно, определен победитель (Студент 2)
Вывод (p1_test2.log): 3 раунда, корректная обработка ничьих с переигровками.

Тест 3: Program1, вывод в файл
Команда: ./tournament 4 -o p1_out.txt
Результат: файл p1_out.txt создан, данные записаны.

Тест 4: Program2, ввод из командной строки, N=4
Команда: ./tournament 4
Результат: успешно, определен победитель.
Вывод (p2_test1.log): корректная работа с барьерами и условными переменными.

Тест 5: Program2, ввод из конфигурационного файла, N=8
Команда: ./tournament -c test_config1.txt
Результат: успешно, определен победитель (Студент 0)
Вывод (p2_test2.log): 3 раунда, корректная обработка ничьих, отсутствие зацикливаний благодаря rand_lock.

Тест 6: Program2, вывод в файл
Команда: ./tournament 4 -o p2_out.txt
Результат: файл p2_out.txt создан, данные записаны.

Тест 7: Нагрузочное тестирование, N=16 (test_config3.txt)
Команда: ./tournament -c test_config3.txt (для обеих программ)
Результат: успешно, проведены турниры на 16 участников (4 раунда).
Вывод: обе программы корректно масштабируются и обрабатывают большее количество потоков.

Все тесты подтверждают корректную работу программ. Обработка ничьих работает корректно в обоих вариантах. Ввод из командной строки и конфигурационных файлов функционирует. Вывод в файл выполняется.

СРАВНИТЕЛЬНЫЙ АНАЛИЗ
Program1 использует семафоры и мьютексы. Генерация случайных чисел через rand_r с индивидуальным сидом.
Program2 использует условные переменные, барьеры и атомарные переменные. Генерация случайных чисел через rand() с глобальным мьютексом rand_lock. Использование мьютекса для rand() необходимо, так как стандартная функция rand() не является потокобезопасной.
При одинаковых входных данных (N) обе программы формируют идентичную структуру турнира (раунды, пары), но конкретные исходы поединков различаются из-за стохастической природы генераторов. Обе программы корректно обрабатывают ничьи путем переигровок до победы.
Program2 демонстрирует альтернативный подход к синхронизации, используя барьер для старта раунда, что упрощает координацию потоков по сравнению с семафорами в Program1. Использование атомарных переменных уменьшает необходимость в явных блокировках для простых счетчиков.

ВЫВОДЫ
Программы реализуют многопоточный турнир в соответствии с ТЗ на 9-10 баллов. Синхронизация обеспечивает корректное проведение поединков. Реализованы все требования: ввод из командной строки/файла, вывод в файл, две различные реализации синхронизации.
